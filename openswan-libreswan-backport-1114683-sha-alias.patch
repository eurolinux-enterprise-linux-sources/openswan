diff -Naur openswan-2.6.32-orig/include/constants.h openswan-2.6.32/include/constants.h
--- openswan-2.6.32-orig/include/constants.h	2014-09-09 17:00:41.876000000 -0400
+++ openswan-2.6.32/include/constants.h	2014-09-09 20:05:34.343000000 -0400
@@ -70,6 +70,7 @@
 
 #define streq(a, b) (strcmp((a), (b)) == 0)	/* clearer shorthand */
 #define strcaseeq(a, b) (strcasecmp((a), (b)) == 0)	/* clearer shorthand */
+#define strncaseeq(a, b, n) (strncasecmp((a), (b), (n)) == 0)
 
 /* set type with room for at least 64 elements for ALG opts
  * (was 32 in stock FS)
diff -Naur openswan-2.6.32-orig/lib/libopenswan/alg_info.c openswan-2.6.32/lib/libopenswan/alg_info.c
--- openswan-2.6.32-orig/lib/libopenswan/alg_info.c	2014-09-09 17:00:41.962000000 -0400
+++ openswan-2.6.32/lib/libopenswan/alg_info.c	2014-09-09 20:05:34.343000000 -0400
@@ -43,6 +43,38 @@
 /* abstract reference */
 struct oakley_group_desc;
 
+#define MAX_ALG_ALIASES 16
+typedef struct alg_alias {
+        const char *alg;
+        const char *alias_set[MAX_ALG_ALIASES];
+} alg_alias;
+/*
+ * Aliases should NOT be used to match a base cipher to a key size,
+ * as that would change the meaning of the loaded connection. For
+ * examples aes cannot become an alias for aes128 or else a responder
+ * with esp=aes would reject aes256.
+ */
+static const alg_alias auth_alg_aliases[] = {
+        /* alg */       /* aliases */
+        { "sha2_256",   { "sha2", NULL } },
+        { "sha1",       { "sha", NULL } },
+        { "sha1",       { "sha1_96", NULL } },
+        { NULL, { NULL } }
+};
+
+static const alg_alias esp_trans_aliases[] = {
+        /* alg */       /* aliases */
+        { "aes_ccm_a",  { "aes_ccm_8",  NULL } },
+        { "aes_ccm_b",  { "aes_ccm_12", NULL } },
+        { "aes_ccm_c",  { "aes_ccm_16", "aes_ccm", NULL } },
+        { "aes_gcm_a",  { "aes_gcm_8", NULL } },
+        { "aes_gcm_b",  { "aes_gcm_12", NULL } },
+        { "aes_gcm_c",  { "aes_gcm_16", "aes_gcm", NULL } },
+        { "aes_ctr",    { "aesctr", NULL } },
+        { "aes",        { "aes_cbc", NULL } },
+        { NULL, { NULL } }
+};
+
 /* sadb/ESP aa attrib converters */
 enum ipsec_authentication_algo
 alg_info_esp_aa2sadb(enum ikev1_auth_attribute auth)
@@ -172,6 +204,24 @@
 	return ret;
 }
 
+/* if str is a known alias, return the real alg */
+static const char *alg_find_alias(const alg_alias *alias, const char *str)
+{
+        const alg_alias *aa;
+        int i;
+
+        for (aa = alias; aa->alg != NULL; aa++) {
+                const char *const *aset = aa->alias_set;
+
+                for (i = 0; i < MAX_ALG_ALIASES && aset[i] != NULL; i++) {
+                        if (strcaseeq(str, aset[i]))
+                                return aa->alg;
+                }
+        }
+
+        return NULL;
+}
+
 /*
  * 	Search esp_transformid_names for a match, eg:
  * 		"3des" <=> "ESP_3DES"
@@ -219,6 +269,24 @@
 out:
 	return ret;
 }
+static int ealg_getbyname_or_alias_esp(const char *str, size_t len)
+{
+        const char *astr = alg_find_alias(esp_trans_aliases, str);
+
+        return astr == NULL ?
+                ealg_getbyname_esp(str, len) :
+                ealg_getbyname_esp(astr, strlen(astr));
+}
+
+static int aalg_getbyname_or_alias_esp(const char *str, size_t len)
+{
+        const char *astr = alg_find_alias(auth_alg_aliases, str);
+
+        return astr == NULL ?
+                aalg_getbyname_esp(str, len) :
+                aalg_getbyname_esp(astr, strlen(astr));
+}
+
 static int
 modp_getbyname_esp(const char *const str, int len)
 {
@@ -555,8 +623,8 @@
     p_ctx->aalg_permit = TRUE;
     p_ctx->state=ST_INI;
     
-    p_ctx->ealg_getbyname=ealg_getbyname_esp;
-    p_ctx->aalg_getbyname=aalg_getbyname_esp;
+    p_ctx->ealg_getbyname=ealg_getbyname_or_alias_esp;
+    p_ctx->aalg_getbyname=aalg_getbyname_or_alias_esp;
 
 }
 
@@ -578,7 +646,7 @@
     p_ctx->state=ST_INI_AA;
     
     p_ctx->ealg_getbyname=NULL;
-    p_ctx->aalg_getbyname=aalg_getbyname_esp;
+    p_ctx->aalg_getbyname=aalg_getbyname_or_alias_esp;
 
 }
 
@@ -805,7 +873,7 @@
 	    switch(ret) {
 	    case ST_END:
 	    case ST_EOF:
-		DBG(DBG_CRYPT, DBG_log("alg_info_parse_str() "
+		DBG(DBG_CONTROL, DBG_log("alg_info_parse_str() "
 				       "ealg_buf=%s aalg_buf=%s"
 				       "eklen=%d  aklen=%d",
 				       ctx.ealg_buf, ctx.aalg_buf,
diff -Naur openswan-2.6.32-orig/programs/pluto/connections.c openswan-2.6.32/programs/pluto/connections.c
--- openswan-2.6.32-orig/programs/pluto/connections.c	2014-09-09 17:00:41.899000000 -0400
+++ openswan-2.6.32/programs/pluto/connections.c	2014-09-09 20:05:34.344000000 -0400
@@ -1181,22 +1181,28 @@
 	loglog(RC_CLASH, "the protocol must be the same for leftport and rightport");
     }
 #endif
-    else if(wm->ike != NULL
-	    && ((alg_info_ike = alg_info_ike_create_from_str(wm->ike, &ugh))==NULL
-		|| alg_info_ike->alg_info_cnt==0)) {
+    if(wm->ike != NULL) {
+	// char err_buf[256];
+
+	alg_info_ike = alg_info_ike_create_from_str(wm->ike,
+		&ugh);
+
+	if (alg_info_ike == NULL) {
+		loglog(RC_LOG_SERIOUS, "ike string error: %s",
+			ugh? ugh: "unknown");
+		return;
+	}
+
 	if (alg_info_ike!= NULL && alg_info_ike->alg_info_cnt==0) {
-	    loglog(RC_NOALGO
+	    loglog(RC_LOG_SERIOUS
 		   , "got 0 transforms for ike=\"%s\""
 		   , wm->ike);
 	    return;
 	} 
 
-	loglog(RC_NOALGO
-	       , "esp string error: %s"
-	       , ugh? ugh : "Unknown");
-	return;
     }
-    else if ((wm->ike == NULL || alg_info_ike != NULL)
+
+    if ((wm->ike == NULL || alg_info_ike != NULL)
 	     && check_connection_end(&wm->right, &wm->left, wm)
 	     && check_connection_end(&wm->left, &wm->right, wm))
     {
diff -Naur openswan-2.6.32-orig/programs/pluto/plutoalg.c openswan-2.6.32/programs/pluto/plutoalg.c
--- openswan-2.6.32-orig/programs/pluto/plutoalg.c	2014-09-09 17:00:41.965000000 -0400
+++ openswan-2.6.32/programs/pluto/plutoalg.c	2014-09-09 20:06:44.431000000 -0400
@@ -70,18 +70,42 @@
  * @return int Registered # of Hash ALG if loaded.
  */
 static int
-aalg_getbyname_ike(const char *const str, int len)
+aalg_getbyname_ike(const char *str, int len)
 {
 	int ret=-1;
 	unsigned num;
+	static const char sha2_256_aka[] = "sha2";
+	static const char sha1_aka[] = "sha";
+
 	if (!str||!*str)
-		goto out;
+		return -1;
+
+        /* handle "sha2" as "sha2_256" */
+        if (len == sizeof(sha2_256_aka)-1 &&
+            strncaseeq(str, sha2_256_aka, sizeof(sha2_256_aka)-1)) {
+                DBG_log("interpreting sha2 as sha2_256");
+                str = "sha2_256";
+                len = strlen(str);
+        }
+
+        /* now "sha" as "sha1" */
+        if (len == sizeof(sha1_aka)-1 &&
+            strncaseeq(str, sha1_aka, sizeof(sha1_aka)-1)) {
+                DBG_log("interpreting sha as sha1");
+                str = "sha1";
+                len = strlen(str);
+        }
+
 	ret=alg_enum_search_prefix(&oakley_hash_names,"OAKLEY_",str,len);
-	if (ret>=0) goto out;
+	if (ret>=0) return ret;
+
+	/* Special value for no authentication since zero is already used. */
+	if (len == 4 && strncaseeq(str, "null", len))
+		return INT_MAX;
+
 	sscanf(str, "id%d%n", &ret, &num);
 	if (ret >=0 && num!=strlen(str))
-		ret=-1;
-out:
+		return -1;
 	return ret;
 }
 /**
