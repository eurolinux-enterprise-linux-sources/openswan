diff -Naur openswan-2.6.32-orig/lib/libopenswan/constants.c openswan-2.6.32/lib/libopenswan/constants.c
--- openswan-2.6.32-orig/lib/libopenswan/constants.c	2014-06-22 11:49:27.943000000 -0400
+++ openswan-2.6.32/lib/libopenswan/constants.c	2014-06-22 14:02:16.863000000 -0400
@@ -775,13 +775,6 @@
 
 /* Oakley Hash Algorithm attribute */
 
-static const char *const oakley_hash_name2[] = {
-	"OAKLEY_SHA",
-    };
-
-enum_names oakley_hash_names2 =
-    { OAKLEY_SHA, OAKLEY_SHA, oakley_hash_name2, NULL };
-
 static const char *const oakley_hash_name[] = {
 	"OAKLEY_MD5",
 	"OAKLEY_SHA1",
@@ -792,7 +785,7 @@
     };
 
 enum_names oakley_hash_names =
-    { OAKLEY_MD5, OAKLEY_SHA2_512, oakley_hash_name, &oakley_hash_names2};
+    { OAKLEY_MD5, OAKLEY_SHA2_512, oakley_hash_name, NULL };
 
 /* Oakley Authentication Method attribute */
 
diff -Naur openswan-2.6.32-orig/programs/pluto/crypt_dh.c openswan-2.6.32/programs/pluto/crypt_dh.c
--- openswan-2.6.32-orig/programs/pluto/crypt_dh.c	2014-06-22 11:49:27.930000000 -0400
+++ openswan-2.6.32/programs/pluto/crypt_dh.c	2014-06-22 14:20:53.532000000 -0400
@@ -296,7 +296,7 @@
     chunk_t nir;
     int k;
     CK_MECHANISM_TYPE mechanism;
-    u_char buf1[HMAC_BUFSIZE], buf2[HMAC_BUFSIZE];
+    u_char buf1[HMAC_BUFSIZE * 2], buf2[HMAC_BUFSIZE * 2];
     chunk_t buf1_chunk, buf2_chunk;
     PK11SymKey *shared, *skeyid;
 
@@ -317,9 +317,9 @@
     memcpy(nir.ptr, ni.ptr, ni.len);
     memcpy(nir.ptr+ ni.len, nr.ptr, nr.len);
 
-    memset(buf1, '\0', HMAC_BUFSIZE);
+    zero(&buf1);
 
-    if (pss.len <= HMAC_BUFSIZE)
+    if (pss.len <= hasher->hash_block_size)
     {
         memcpy(buf1, pss.ptr, pss.len);
     }
@@ -330,9 +330,9 @@
         hasher->hash_final(buf1, &ctx.hash_ctx);
     }
 
-    memcpy(buf2, buf1, HMAC_BUFSIZE);
+    memcpy(buf2, buf1, hasher->hash_block_size);
 
-    for (k = 0; k < HMAC_BUFSIZE; k++)
+    for (k = 0; k < hasher->hash_block_size; k++)
     {
         buf1[k] ^= HMAC_IPAD;
         buf2[k] ^= HMAC_OPAD;
@@ -342,16 +342,16 @@
 
     mechanism=nss_key_derivation_mech(hasher);
     buf1_chunk.ptr=buf1;
-    buf1_chunk.len=HMAC_BUFSIZE;
+    buf1_chunk.len=hasher->hash_block_size;
 
     buf2_chunk.ptr=buf2;
-    buf2_chunk.len=HMAC_BUFSIZE;
+    buf2_chunk.len=hasher->hash_block_size;
 
     PK11SymKey *tkey4 = pk11_derive_wrapper_osw(shared, CKM_CONCATENATE_DATA_AND_BASE, buf1_chunk, CKM_EXTRACT_KEY_FROM_KEY, CKA_DERIVE, 0);
     /* nss_symkey_log(tkey4, "pss+ipad+shared"); */
 
     CK_EXTRACT_PARAMS bs=0;
-    PK11SymKey *tkey5 = pk11_extract_derive_wrapper_osw(tkey4, bs, CKM_CONCATENATE_BASE_AND_DATA, CKA_DERIVE, HMAC_BUFSIZE);
+    PK11SymKey *tkey5 = pk11_extract_derive_wrapper_osw(tkey4, bs, CKM_CONCATENATE_BASE_AND_DATA, CKA_DERIVE, hasher->hash_block_size);
     /* nss_symkey_log(tkey5, "pss+ipad"); */
 
     PK11SymKey *tkey6 = pk11_derive_wrapper_osw(tkey5, CKM_CONCATENATE_BASE_AND_DATA, nir, mechanism, CKA_DERIVE, 0);
@@ -405,7 +405,7 @@
 #ifdef HAVE_LIBNSS
     int k;
     CK_MECHANISM_TYPE mechanism;
-    u_char buf1[HMAC_BUFSIZE], buf2[HMAC_BUFSIZE];
+    u_char buf1[HMAC_BUFSIZE * 2], buf2[HMAC_BUFSIZE * 2];
     chunk_t buf1_chunk, buf2_chunk;
     PK11SymKey *shared, *skeyid;
 #endif
@@ -435,8 +435,8 @@
     hmac_final_chunk(*skeyid_chunk, "st_skeyid in skeyid_digisig()", &ctx);
     DBG(DBG_CRYPT, DBG_dump_chunk("keyid: ", *skeyid_chunk));
 #else
-    memset(buf1, '\0', HMAC_BUFSIZE);
-    if (nir.len <= HMAC_BUFSIZE)
+    zero(&buf1);
+    if (nir.len <= hasher->hash_block_size)
     {
 	memcpy(buf1, nir.ptr, nir.len);
     }
@@ -447,9 +447,9 @@
 	hasher->hash_final(buf1, &ctx.hash_ctx);
     }
 
-    memcpy(buf2, buf1, HMAC_BUFSIZE);
+    memcpy(buf2, buf1, hasher->hash_block_size);
 
-    for (k = 0; k < HMAC_BUFSIZE; k++)
+    for (k = 0; k < hasher->hash_block_size; k++)
     {
 	buf1[k] ^= HMAC_IPAD;
 	buf2[k] ^= HMAC_OPAD;
@@ -458,10 +458,10 @@
     pfree(nir.ptr);
     mechanism=nss_key_derivation_mech(hasher);
     buf1_chunk.ptr=buf1;
-    buf1_chunk.len=HMAC_BUFSIZE;
+    buf1_chunk.len=hasher->hash_block_size;
 
     buf2_chunk.ptr=buf2;
-    buf2_chunk.len=HMAC_BUFSIZE;
+    buf2_chunk.len=hasher->hash_block_size;
 
     PK11SymKey *tkey1 = pk11_derive_wrapper_osw(shared, CKM_CONCATENATE_DATA_AND_BASE, buf1_chunk, mechanism, CKA_DERIVE, 0);
     PK11SymKey *tkey2 = PK11_Derive_osw(tkey1, mechanism, NULL, CKM_CONCATENATE_DATA_AND_BASE, CKA_DERIVE, 0);
@@ -564,9 +564,9 @@
     CK_OBJECT_HANDLE keyhandle;
     SECItem param, param1;
 
-    hmac_opad = hmac_pads(HMAC_OPAD,HMAC_BUFSIZE);
-    hmac_ipad = hmac_pads(HMAC_IPAD,HMAC_BUFSIZE);
-    hmac_pad  = hmac_pads(0x00,HMAC_BUFSIZE-hasher->hash_digest_len);
+    hmac_opad = hmac_pads(HMAC_OPAD, hasher->hash_block_size);
+    hmac_ipad = hmac_pads(HMAC_IPAD, hasher->hash_block_size);
+    hmac_pad  = hmac_pads(0x00, hasher->hash_block_size-hasher->hash_digest_len);
     hmac_zerobyte = hmac_pads(0x00,1);
     hmac_val1 = hmac_pads(0x01,1);
     hmac_val2 = hmac_pads(0x02,1);
@@ -575,7 +575,7 @@
 
     /*Deriving SKEYID_d = hmac_xxx(SKEYID, g^xy | CKY-I | CKY-R | 0) */
     PK11SymKey *tkey1 = pk11_derive_wrapper_osw(skeyid, CKM_CONCATENATE_BASE_AND_DATA
-                                                , hmac_pad,CKM_XOR_BASE_AND_DATA, CKA_DERIVE, HMAC_BUFSIZE);
+                                                , hmac_pad,CKM_XOR_BASE_AND_DATA, CKA_DERIVE, hasher->hash_block_size);
 
     PR_ASSERT(tkey1!=NULL);
 
@@ -744,7 +744,7 @@
         //nss_symkey_log(skeyid_e, "skeyid_e");
 
         PK11SymKey *tkey25 = pk11_derive_wrapper_osw(skeyid_e, CKM_CONCATENATE_BASE_AND_DATA
-                                                , hmac_pad,CKM_XOR_BASE_AND_DATA, CKA_DERIVE, HMAC_BUFSIZE);
+                                                , hmac_pad,CKM_XOR_BASE_AND_DATA, CKA_DERIVE,  hasher->hash_block_size);
         PR_ASSERT(tkey25!=NULL);
 
         PK11SymKey *tkey26 = pk11_derive_wrapper_osw(tkey25, CKM_XOR_BASE_AND_DATA
@@ -778,7 +778,7 @@
        i += hasher->hash_digest_len;
 
         PK11SymKey *tkey32 = pk11_derive_wrapper_osw(skeyid_e, CKM_CONCATENATE_BASE_AND_DATA
-                                                , hmac_pad,CKM_XOR_BASE_AND_DATA, CKA_DERIVE, HMAC_BUFSIZE);
+                                                , hmac_pad,CKM_XOR_BASE_AND_DATA, CKA_DERIVE,  hasher->hash_block_size);
         PR_ASSERT(tkey32!=NULL);
 
         PK11SymKey *tkey33 = pk11_derive_wrapper_osw(tkey32, CKM_XOR_BASE_AND_DATA
@@ -1247,9 +1247,9 @@
     passert(encrypter);
 
 
-    hmac_opad = hmac_pads(HMAC_OPAD,HMAC_BUFSIZE);
-    hmac_ipad = hmac_pads(HMAC_IPAD,HMAC_BUFSIZE);
-    hmac_pad_prf  = hmac_pads(0x00,HMAC_BUFSIZE-hasher->hash_digest_len);
+    hmac_opad = hmac_pads(HMAC_OPAD, hasher->hash_block_size);
+    hmac_ipad = hmac_pads(HMAC_IPAD, hasher->hash_block_size);
+    hmac_pad_prf  = hmac_pads(0x00, hasher->hash_block_size-hasher->hash_digest_len);
 
 
     /* generate SKEYSEED from key=(Ni|Nr), hash of shared */
@@ -1333,7 +1333,7 @@
 
 	PK11SymKey *finalkey;
 	PK11SymKey *tkey1 = pk11_derive_wrapper_osw(skeyseed_k, CKM_CONCATENATE_BASE_AND_DATA
-		, hmac_pad_prf,CKM_XOR_BASE_AND_DATA, CKA_DERIVE, HMAC_BUFSIZE);
+		, hmac_pad_prf,CKM_XOR_BASE_AND_DATA, CKA_DERIVE,  hasher->hash_block_size);
 	PR_ASSERT(tkey1!=NULL);
 
 
diff -Naur openswan-2.6.32-orig/programs/pluto/crypto.c openswan-2.6.32/programs/pluto/crypto.c
--- openswan-2.6.32-orig/programs/pluto/crypto.c	2010-12-17 20:23:54.000000000 -0500
+++ openswan-2.6.32/programs/pluto/crypto.c	2014-06-22 14:22:56.853000000 -0400
@@ -127,6 +127,7 @@
     hash_key_size:   MD5_DIGEST_SIZE,
     hash_digest_len: MD5_DIGEST_SIZE,
     hash_integ_len: 0,				/*Not applicable*/
+    hash_block_size: HMAC_BUFSIZE,
     hash_init: (void (*)(void *)) osMD5Init,
     hash_update: (void (*)(void *, const u_int8_t *, size_t)) osMD5Update,
     hash_final: (void (*)(u_char *, void *)) osMD5Final,
@@ -144,6 +145,7 @@
     hash_key_size:   MD5_DIGEST_SIZE,
     hash_digest_len: MD5_DIGEST_SIZE,
     hash_integ_len: MD5_DIGEST_SIZE_96,	
+    hash_block_size: HMAC_BUFSIZE,
     hash_init: (void (*)(void *)) osMD5Init,
     hash_update: (void (*)(void *, const u_int8_t *, size_t)) osMD5Update,
     hash_final: (void (*)(u_char *, void *)) osMD5Final,
@@ -161,6 +163,7 @@
     hash_key_size:   SHA1_DIGEST_SIZE,
     hash_digest_len: SHA1_DIGEST_SIZE,
     hash_integ_len: 0,                          /*Not applicable*/
+    hash_block_size: HMAC_BUFSIZE,
     hash_init: (void (*)(void *)) SHA1Init,
     hash_update: (void (*)(void *, const u_int8_t *, size_t)) SHA1Update,
     hash_final: (void (*)(u_char *, void *)) SHA1Final,
@@ -178,6 +181,7 @@
     hash_key_size:   SHA1_DIGEST_SIZE,
     hash_digest_len: SHA1_DIGEST_SIZE,
     hash_integ_len: SHA1_DIGEST_SIZE_96,
+    hash_block_size: HMAC_BUFSIZE,
     hash_init: (void (*)(void *)) SHA1Init,
     hash_update: (void (*)(void *, const u_int8_t *, size_t)) SHA1Update,
     hash_final: (void (*)(u_char *, void *)) SHA1Final,
diff -Naur openswan-2.6.32-orig/programs/pluto/hmac.c openswan-2.6.32/programs/pluto/hmac.c
--- openswan-2.6.32-orig/programs/pluto/hmac.c	2014-06-22 11:49:27.792000000 -0400
+++ openswan-2.6.32/programs/pluto/hmac.c	2014-06-22 14:26:18.349000000 -0400
@@ -71,11 +71,11 @@
     memcpy(&symkey, key, key_len);
     klen =  PK11_GetKeyLength(symkey);
 
-    hmac_opad = hmac_pads(HMAC_OPAD,HMAC_BUFSIZE);
-    hmac_ipad = hmac_pads(HMAC_IPAD,HMAC_BUFSIZE);
-    hmac_pad  = hmac_pads(0x00,HMAC_BUFSIZE-klen);
+    hmac_opad = hmac_pads(HMAC_OPAD,h->hash_block_size);
+    hmac_ipad = hmac_pads(HMAC_IPAD,h->hash_block_size);
+    hmac_pad  = hmac_pads(0x00,h->hash_block_size-klen);
 
-    if(klen > HMAC_BUFSIZE) 
+    if(klen > h->hash_block_size) 
     {
 	tkey1 = PK11_Derive_osw(symkey, nss_key_derivation_mech(h)
 				, NULL, CKM_CONCATENATE_BASE_AND_DATA, CKA_DERIVE, 0);
@@ -86,7 +86,7 @@
     }
 
     PK11SymKey *tkey2 = pk11_derive_wrapper_osw(tkey1, CKM_CONCATENATE_BASE_AND_DATA
-				, hmac_pad,CKM_XOR_BASE_AND_DATA, CKA_DERIVE, HMAC_BUFSIZE);
+				, hmac_pad,CKM_XOR_BASE_AND_DATA, CKA_DERIVE, h->hash_block_size);
 
     PR_ASSERT(tkey2!=NULL);
     ctx->ikey = pk11_derive_wrapper_osw(tkey2, CKM_XOR_BASE_AND_DATA
@@ -266,7 +266,7 @@
 {
 	SECOidTag oid;
 	PK11Context *ctx;
-	unsigned char dkey[HMAC_BUFSIZE];
+	unsigned char dkey[HMAC_BUFSIZE * 2];
 	SECItem dkey_param;
 	SECStatus status;
 	unsigned int len=0;
diff -Naur openswan-2.6.32-orig/programs/pluto/ike_alg.h openswan-2.6.32/programs/pluto/ike_alg.h
--- openswan-2.6.32-orig/programs/pluto/ike_alg.h	2010-12-17 20:23:54.000000000 -0500
+++ openswan-2.6.32/programs/pluto/ike_alg.h	2014-06-22 14:26:54.481000000 -0400
@@ -38,6 +38,7 @@
     size_t hash_ctx_size;
     size_t hash_digest_len;
     size_t hash_integ_len;        /*truncated output len when used as an integrity algorithm in IKEV2*/
+    size_t hash_block_size;
     void (*hash_init)(void *ctx);
     hash_update_t hash_update;
     void (*hash_final)(u_int8_t *out, void *ctx);
diff -Naur openswan-2.6.32-orig/programs/pluto/ike_alg_sha2.c openswan-2.6.32/programs/pluto/ike_alg_sha2.c
--- openswan-2.6.32-orig/programs/pluto/ike_alg_sha2.c	2010-12-17 20:23:54.000000000 -0500
+++ openswan-2.6.32/programs/pluto/ike_alg_sha2.c	2014-06-22 14:29:19.746000000 -0400
@@ -31,6 +31,18 @@
 	memcpy(hash, &ctx->sha_out[0], SHA2_256_DIGEST_SIZE);
 #endif
 }
+
+static void sha384_hash_final(u_char *hash, sha512_context *ctx)
+{
+	unsigned int len;
+	SECStatus s;
+	s = PK11_DigestFinal(ctx->ctx_nss, hash, &len, SHA2_384_DIGEST_SIZE);
+	PR_ASSERT(len == SHA2_384_DIGEST_SIZE);
+	PR_ASSERT(s==SECSuccess);
+	PK11_DestroyContext(ctx->ctx_nss, PR_TRUE);
+	DBG(DBG_CRYPT, DBG_log("NSS SHA 384 hash final : end"));
+}
+
 static void sha512_hash_final(u_char *hash, sha512_context *ctx)
 {
 #ifdef HAVE_LIBNSS
@@ -46,6 +58,7 @@
 	memcpy(hash, &ctx->sha_out[0], SHA2_512_DIGEST_SIZE);
 #endif
 }
+
 struct hash_desc hash_desc_sha2_256 = {
 	common:{officname:  "sha256",
 		algo_type: IKE_ALG_HASH,
@@ -56,6 +69,7 @@
 	hash_key_size: SHA2_256_DIGEST_SIZE,
 	hash_digest_len: SHA2_256_DIGEST_SIZE,
 	hash_integ_len: 0,	/*Not applicable*/
+	hash_block_size: HMAC_BUFSIZE,
 	hash_init: (void (*)(void *))sha256_init,
 	hash_update: (void (*)(void *, const u_char *, size_t ))sha256_write,
 	hash_final:(void (*)(u_char *, void *))sha256_hash_final,
@@ -71,36 +85,93 @@
         hash_key_size: SHA2_256_DIGEST_SIZE,
         hash_digest_len: SHA2_256_DIGEST_SIZE,
         hash_integ_len: SHA2_256_DIGEST_SIZE/2,
+	hash_block_size: HMAC_BUFSIZE,
         hash_init: (void (*)(void *))sha256_init,
         hash_update: (void (*)(void *, const u_char *, size_t ))sha256_write,
         hash_final:(void (*)(u_char *, void *))sha256_hash_final,
 };
 
+static struct hash_desc hash_desc_sha2_384 = {
+	common:{ officname:   "sha384",
+		algo_type:  IKE_ALG_HASH,
+		algo_id:    OAKLEY_SHA2_384,
+		algo_v2id: IKEv2_PRF_HMAC_SHA2_384,
+		algo_next:  NULL, },
+	hash_ctx_size:  sizeof(sha512_context),
+	hash_key_size:  SHA2_384_DIGEST_SIZE,
+	hash_digest_len:  SHA2_384_DIGEST_SIZE,
+	hash_integ_len:  0,    /*Not applicable*/
+	hash_block_size: HMAC_BUFSIZE*2,        
+	hash_init:  (void (*)(void *))sha384_init,
+	hash_update:  (void (*)(void *, const u_char *, size_t ))sha512_write,
+	hash_final:  (void (*)(u_char *, void *))sha384_hash_final,
+};
+
+static struct hash_desc integ_desc_sha2_384 = {
+	common:{ officname:  "sha384",
+		algo_type: IKE_ALG_INTEG,
+		algo_id:   OAKLEY_SHA2_384,
+		algo_v2id: IKEv2_AUTH_HMAC_SHA2_384_192,
+		algo_next: NULL, },
+	hash_ctx_size: sizeof(sha512_context),
+	hash_key_size: SHA2_384_DIGEST_SIZE,
+	hash_digest_len: SHA2_384_DIGEST_SIZE,
+	hash_integ_len: SHA2_384_DIGEST_SIZE / 2,
+	hash_block_size: HMAC_BUFSIZE*2,        
+	hash_init: (void (*)(void *))sha384_init,
+	hash_update: (void (*)(void *, const u_char *, size_t ))sha512_write,
+	hash_final: (void (*)(u_char *, void *))sha384_hash_final,
+};
+
 struct hash_desc hash_desc_sha2_512 = {
 	common:{officname: "sha512",
 		algo_type: IKE_ALG_HASH,
 		algo_id:   OAKLEY_SHA2_512,
+		algo_v2id: IKEv2_PRF_HMAC_SHA2_512,
 		algo_next: NULL, },
 	hash_ctx_size: sizeof(sha512_context),
-	hash_key_size: 0,
+	hash_key_size: SHA2_512_DIGEST_SIZE,
 	hash_digest_len: SHA2_512_DIGEST_SIZE,
 	hash_integ_len: 0,      /*Not applicable*/
+	hash_block_size: HMAC_BUFSIZE*2,
+	hash_init: (void (*)(void *))sha512_init,
+	hash_update: (void (*)(void *, const u_char *, size_t ))sha512_write,
+	hash_final:(void (*)(u_char *, void *))sha512_hash_final,
+};
+
+struct hash_desc integ_desc_sha2_512 = {
+	common:{officname: "sha512",
+		algo_type: IKE_ALG_INTEG,
+		algo_id:   OAKLEY_SHA2_512,
+		algo_v2id: IKEv2_AUTH_HMAC_SHA2_512_256,
+		algo_next: NULL, },
+	hash_ctx_size: sizeof(sha512_context),
+	hash_key_size: SHA2_512_DIGEST_SIZE,
+	hash_digest_len: SHA2_512_DIGEST_SIZE,
+	hash_integ_len: SHA2_512_DIGEST_SIZE / 2,
+	hash_block_size: HMAC_BUFSIZE*2,
 	hash_init: (void (*)(void *))sha512_init,
 	hash_update: (void (*)(void *, const u_char *, size_t ))sha512_write,
 	hash_final:(void (*)(u_char *, void *))sha512_hash_final,
 };
+
 int ike_alg_sha2_init(void);
 int
 ike_alg_sha2_init(void)
 {
 	int ret;
+
 	ret = ike_alg_register_hash(&hash_desc_sha2_512);
-	if (ret)
-		goto out;
-	ret = ike_alg_register_hash(&hash_desc_sha2_256);
+	if (ret == 0) {
+		ret = ike_alg_register_hash(&hash_desc_sha2_384);
+		if (ret == 0) {
+			ret = ike_alg_register_hash(&hash_desc_sha2_256);
 
-	ike_alg_add((struct ike_alg *) &integ_desc_sha2_256);
-out:
+			ike_alg_add((struct ike_alg *) &integ_desc_sha2_256);
+			ike_alg_add((struct ike_alg *) &integ_desc_sha2_384);
+			ike_alg_add((struct ike_alg *) &integ_desc_sha2_512);
+		}
+	}
 	return ret;
 }
 /*
diff -Naur openswan-2.6.32-orig/programs/pluto/kernel_netlink.c openswan-2.6.32/programs/pluto/kernel_netlink.c
--- openswan-2.6.32-orig/programs/pluto/kernel_netlink.c	2014-06-22 11:49:27.927000000 -0400
+++ openswan-2.6.32/programs/pluto/kernel_netlink.c	2014-06-22 14:02:16.864000000 -0400
@@ -145,6 +145,8 @@
 	{ SADB_AALG_SHA1HMAC, "sha1" },
 	{ SADB_X_AALG_SHA2_256HMAC, "sha256" },
 	{ SADB_X_AALG_SHA2_256HMAC_TRUNCBUG, "hmac(sha256)" },
+	{ SADB_X_AALG_SHA2_384HMAC, "sha384" },
+	{ SADB_X_AALG_SHA2_512HMAC, "sha512" },
 	{ SADB_X_AALG_RIPEMD160HMAC, "ripemd160" },
 	{ 0, sparse_end }
 };
diff -Naur openswan-2.6.32-orig/programs/pluto/spdb_v2_struct.c openswan-2.6.32/programs/pluto/spdb_v2_struct.c
--- openswan-2.6.32-orig/programs/pluto/spdb_v2_struct.c	2014-06-22 11:49:27.814000000 -0400
+++ openswan-2.6.32/programs/pluto/spdb_v2_struct.c	2014-06-22 14:02:16.864000000 -0400
@@ -278,6 +278,11 @@
         return IKEv2_AUTH_HMAC_SHA1_96;
     case OAKLEY_SHA2_256:
         return IKEv2_AUTH_HMAC_SHA2_256_128;
+    case OAKLEY_SHA2_384:
+        return IKEv2_AUTH_HMAC_SHA2_384_192;
+    case OAKLEY_SHA2_512:
+        return IKEv2_AUTH_HMAC_SHA2_512_256;
+
     default:
         return IKEv2_AUTH_INVALID;
    }
@@ -292,6 +297,10 @@
         return IKEv2_AUTH_HMAC_SHA1_96;
     case AUTH_ALGORITHM_HMAC_SHA2_256:
         return IKEv2_AUTH_HMAC_SHA2_256_128;
+    case AUTH_ALGORITHM_HMAC_SHA2_384:
+        return IKEv2_AUTH_HMAC_SHA2_384_192;
+    case AUTH_ALGORITHM_HMAC_SHA2_512:
+        return IKEv2_AUTH_HMAC_SHA2_512_256;
     default:
         return IKEv2_AUTH_INVALID;
    }
@@ -307,6 +316,10 @@
         return IKEv2_PRF_HMAC_SHA1;
     case OAKLEY_SHA2_256:
         return IKEv2_PRF_HMAC_SHA2_256;
+    case OAKLEY_SHA2_384:
+        return IKEv2_PRF_HMAC_SHA2_384;
+    case OAKLEY_SHA2_512:
+         return IKEv2_PRF_HMAC_SHA2_512;
     default:
         return IKEv2_PRF_INVALID;
     }
